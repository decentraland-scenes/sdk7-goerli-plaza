"use strict";
// A naive attempt at getting the global `this`. Donâ€™t use `this`!
const getGlobalThis = function () {
    // @ts-ignore
    if (typeof globalThis !== 'undefined')
        return globalThis;
    // @ts-ignore
    if (typeof self !== 'undefined')
        return self;
    // @ts-ignore
    if (typeof window !== 'undefined')
        return window;
    // Note: this might still return the wrong result!
    // @ts-ignore
    if (typeof this !== 'undefined')
        return this;
    throw new Error('Unable to locate global `this`');
};
const globalObject = getGlobalThis();
var loader;
(function (loader) {
    'use strict';
    const MODULE_LOADING = 1;
    const MODULE_READY = 2;
    let unnamedModules = 0;
    const anonymousQueue = [];
    const cycles = [];
    const settings = {
        baseUrl: ''
    };
    const registeredModules = {};
    function config(config) {
        if (typeof config === 'object') {
            for (const x in config) {
                if (config.hasOwnProperty(x)) {
                    ;
                    settings[x] = config[x];
                }
            }
        }
    }
    loader.config = config;
    function define(first, second, third) {
        let moduleToLoad = null;
        let factory = {};
        let dependencies = null;
        if (typeof first === 'function') {
            factory = first;
        }
        else if (typeof first === 'string') {
            moduleToLoad = first;
            if (typeof second === 'function') {
                factory = second;
            }
            else if (second instanceof Array) {
                dependencies = second;
                factory = third;
            }
        }
        else if (first instanceof Array) {
            dependencies = first;
            if (typeof second === 'function') {
                factory = second;
            }
        }
        dependencies = dependencies || ['require', 'exports', 'module'];
        if (moduleToLoad === null) {
            moduleToLoad = `unnamed-module-${unnamedModules++}`;
        }
        moduleToLoad = normalizeModuleId(moduleToLoad);
        function ready(deps) {
            const module = registeredModules[moduleToLoad];
            if (!module)
                throw new Error('Could not access registered module ' + moduleToLoad);
            let exports = module.exports;
            exports =
                typeof factory === 'function'
                    ? factory.apply(globalObject, deps) || exports
                    : factory;
            module.exports = exports;
            moduleReady(moduleToLoad);
        }
        dependencies = (dependencies || []).map((dep) => resolve(moduleToLoad, dep));
        if (!registeredModules[moduleToLoad]) {
            registeredModules[moduleToLoad] = {
                name: moduleToLoad,
                parent: null,
                dclamd: MODULE_LOADING,
                dependencies,
                handlers: [],
                exports: {},
                dependants: new Set()
            };
        }
        registeredModules[moduleToLoad].dependencies = dependencies;
        require(dependencies, ready, (err) => {
            if (typeof onerror === 'function') {
                onerror(err);
            }
            else {
                throw err;
            }
        }, moduleToLoad);
    }
    loader.define = define;
    (function (define) {
        define.amd = {};
        define.modules = registeredModules;
    })(define = loader.define || (loader.define = {}));
    function moduleReady(moduleName) {
        const module = registeredModules[moduleName];
        if (!module)
            throw new Error('Could not access registered module ' + moduleName);
        module.dclamd = MODULE_READY;
        const handlers = module.handlers;
        if (handlers && handlers.length) {
            for (let x = 0; x < handlers.length; x++) {
                handlers[x](registeredModules[moduleName]);
            }
        }
    }
    /**
     * Walks (recursively) the dependencies of 'from' in search of 'to'.
     * Returns cycle as array.
     */
    function getCyclePath(fromModule, toModule, depth) {
        if (!registeredModules[fromModule]) {
            return null;
        }
        if (fromModule === toModule || depth === 50)
            return [fromModule];
        const dependencies = registeredModules[fromModule].dependencies;
        for (let i = 0, len = dependencies.length; i < len; i++) {
            const path = getCyclePath(dependencies[i], toModule, depth + 1);
            if (path !== null) {
                path.push(fromModule);
                return path;
            }
        }
        return null;
    }
    /**
     * Walks (recursively) the dependencies of 'from' in search of 'to'.
     * Returns true if there is such a path or false otherwise.
     * @param from Module id to start at
     * @param to Module id to look for
     */
    function hasDependencyPath(fromId, toId) {
        const from = registeredModules[fromId];
        if (!from) {
            return false;
        }
        const inQueue = {};
        for (const i in registeredModules) {
            inQueue[i] = false;
        }
        const queue = [];
        // Insert 'from' in queue
        queue.push(from);
        inQueue[fromId] = true;
        while (queue.length > 0) {
            // Pop first inserted element of queue
            const element = queue.shift();
            const dependencies = element.dependencies;
            if (dependencies) {
                // Walk the element's dependencies
                for (let i = 0, len = dependencies.length; i < len; i++) {
                    const dependency = dependencies[i];
                    if (dependency === toId) {
                        // There is a path to 'to'
                        return true;
                    }
                    const dependencyModule = registeredModules[dependency];
                    if (dependencyModule && !inQueue[dependency]) {
                        // Insert 'dependency' in queue
                        inQueue[dependency] = true;
                        queue.push(dependencyModule);
                    }
                }
            }
        }
        // There is no path to 'to'
        return false;
    }
    function require(dependencies, callback, errorCallback, parentModule) {
        const dependenciesResults = new Array(dependencies.length).fill(null);
        let loadedCount = 0;
        let hasLoaded = false;
        if (typeof dependencies === 'string') {
            if (registeredModules[dependencies]) {
                if (registeredModules[dependencies].dclamd === MODULE_LOADING) {
                    throw new Error(`Trying to load ${dependencies} from ${parentModule}. The first module is still loading.`);
                }
                return registeredModules[dependencies];
            }
            throw new Error(dependencies +
                ' has not been defined. Please include it as a dependency in ' +
                parentModule +
                "'s define()");
        }
        const depsLength = dependencies.length;
        for (let index = 0; index < depsLength; index++) {
            switch (dependencies[index]) {
                case 'require':
                    const _require = function (new_module, callback, errorCallback) {
                        return require(new_module, callback, errorCallback, parentModule);
                    };
                    _require.toUrl = function (module) {
                        return toUrl(module, parentModule);
                    };
                    dependenciesResults[index] = _require;
                    loadedCount++;
                    break;
                case 'exports':
                    if (!registeredModules[parentModule]) {
                        throw new Error('Parent module ' + parentModule + ' not registered yet');
                    }
                    dependenciesResults[index] = registeredModules[parentModule].exports;
                    loadedCount++;
                    break;
                case 'module':
                    dependenciesResults[index] = {
                        id: parentModule,
                        uri: toUrl(parentModule)
                    };
                    loadedCount++;
                    break;
                default: {
                    // If we have a circular dependency, then we resolve the module even if it hasn't loaded yet
                    const dependency = dependencies[index];
                    const hasCycles = hasDependencyPath(dependency, parentModule);
                    const handleLoadedModule = () => {
                        dependenciesResults[index] = registeredModules[dependency].exports;
                        loadedCount++;
                        if (loadedCount === depsLength && callback) {
                            hasLoaded = true;
                            callback(dependenciesResults);
                        }
                    };
                    if (hasCycles) {
                        const cyclePath = getCyclePath(dependency, parentModule, 0);
                        if (cyclePath) {
                            cyclePath.reverse();
                            cyclePath.push(dependency);
                            cycles.push(cyclePath);
                        }
                        load(dependency, () => { }, errorCallback, parentModule);
                        handleLoadedModule();
                    }
                    else {
                        load(dependency, handleLoadedModule, errorCallback, parentModule);
                    }
                    break;
                }
            }
        }
        if (!hasLoaded && loadedCount === depsLength && callback) {
            callback(dependenciesResults);
        }
    }
    loader.require = require;
    function createMethodHandler(rpcHandle, method) {
        return function () {
            return dcl.callRpc(rpcHandle, method.name, 
            // eslint-disable-next-line prefer-rest-params
            anonymousQueue.slice.call(arguments, 0));
        };
    }
    // returns: resolvedModuleName
    function resolve(fromModule, toModule) {
        return fromModule ? toUrl(toModule, fromModule) : toModule;
    }
    function load(moduleName, callback, errorCallback, parentModule) {
        if (registeredModules[moduleName]) {
            registeredModules[moduleName].dependants.add(parentModule);
            if (registeredModules[moduleName].dclamd === MODULE_LOADING) {
                callback && registeredModules[moduleName].handlers.push(callback);
            }
            else {
                callback && callback(registeredModules[moduleName]);
            }
            return;
        }
        else {
            registeredModules[moduleName] = {
                name: moduleName,
                parent: parentModule,
                dclamd: MODULE_LOADING,
                handlers: [callback],
                dependencies: [],
                dependants: new Set([parentModule]),
                exports: {}
            };
        }
        if (moduleName.indexOf('@') === 0 || moduleName.indexOf('~') === 0) {
            const exports = registeredModules[moduleName].exports;
            if (typeof dcl.loadModule === 'function') {
                dcl
                    .loadModule(moduleName, exports)
                    .then((descriptor) => {
                    for (const i in descriptor.methods) {
                        const method = descriptor.methods[i];
                        exports[method.name] = createMethodHandler(descriptor.rpcHandle, method);
                    }
                    moduleReady(moduleName);
                })
                    .catch((e) => {
                    errorCallback(e);
                });
            }
            else {
                throw new Error('Asynchronous modules will not work because loadModule function is not present');
            }
        }
    }
    if (typeof dcl !== 'undefined') {
        dcl.onStart(() => {
            const unknownModules = new Set();
            const notLoadedModules = [];
            for (const i in registeredModules) {
                if (registeredModules[i]) {
                    if (registeredModules[i].dclamd === MODULE_LOADING) {
                        notLoadedModules.push(registeredModules[i]);
                    }
                    registeredModules[i].dependencies.forEach(($) => {
                        if ($ === 'require' || $ === 'exports' || $ === 'module')
                            return;
                        if (!registeredModules[$])
                            unknownModules.add($);
                    });
                }
            }
            const errorParts = [];
            if (cycles.length) {
                errorParts.push(`\n> Cyclic dependencies: ${cycles
                    .map(($) => '\n  - ' + $.join(' -> '))
                    .join('')}`);
            }
            if (unknownModules.size) {
                errorParts.push(`\n> Undeclared/unknown modules: ${Array.from(unknownModules)
                    .map(($) => '\n  - ' + $)
                    .join('')}`);
            }
            if (notLoadedModules.length) {
                errorParts.push(`\n> These modules didn't load: ${notLoadedModules
                    .map(($) => '\n  - ' + $.name)
                    .join('')}.\n`);
            }
            if (errorParts.length) {
                throw new Error(errorParts.join('\n'));
            }
        });
    }
    /**
     * Normalize 'a/../name' to 'name', etc.
     */
    function normalizeModuleId(moduleId) {
        let r = moduleId, pattern;
        // replace /./ => /
        pattern = /\/\.\//;
        while (pattern.test(r)) {
            r = r.replace(pattern, '/');
        }
        // replace ^./ => nothing
        r = r.replace(/^\.\//g, '');
        // replace /aa/../ => / (BUT IGNORE /../../)
        pattern =
            /\/(([^\/])|([^\/][^\/\.])|([^\/\.][^\/])|([^\/][^\/][^\/]+))\/\.\.\//;
        while (pattern.test(r)) {
            r = r.replace(pattern, '/');
        }
        // replace ^aa/../ => nothing (BUT IGNORE ../../)
        r = r.replace(/^(([^\/])|([^\/][^\/\.])|([^\/\.][^\/])|([^\/][^\/][^\/]+))\/\.\.\//, '');
        // replace ^/ => nothing
        r = r.replace(/^\//g, '');
        return r;
    }
    /**
     * Resolve relative module ids
     */
    function resolveModule(moduleId, parentModule) {
        let result = moduleId;
        if (!result.startsWith('@') && !result.startsWith('~')) {
            if (result.startsWith('./') || result.startsWith('../')) {
                const currentPath = parentModule.split('/');
                currentPath.pop();
                result = normalizeModuleId(currentPath.join('/') + '/' + result);
            }
        }
        return result;
    }
    function toUrl(moduleName, parentModule) {
        switch (moduleName) {
            case 'require':
            case 'exports':
            case 'module':
                return moduleName;
        }
        if (parentModule) {
            return resolveModule(moduleName, parentModule);
        }
        return normalizeModuleId(moduleName);
    }
    require.toUrl = toUrl;
})(loader || (loader = {}));
globalObject.define = loader.define;
globalObject.dclamd = loader;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW1kLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2FtZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBZ0JBLGtFQUFrRTtBQUNsRSxNQUFNLGFBQWEsR0FBRztJQUNwQixhQUFhO0lBQ2IsSUFBSSxPQUFPLFVBQVUsS0FBSyxXQUFXO1FBQUUsT0FBTyxVQUFVLENBQUE7SUFDeEQsYUFBYTtJQUNiLElBQUksT0FBTyxJQUFJLEtBQUssV0FBVztRQUFFLE9BQU8sSUFBSSxDQUFBO0lBQzVDLGFBQWE7SUFDYixJQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVc7UUFBRSxPQUFPLE1BQU0sQ0FBQTtJQUNoRCxrREFBa0Q7SUFDbEQsYUFBYTtJQUNiLElBQUksT0FBTyxJQUFJLEtBQUssV0FBVztRQUFFLE9BQU8sSUFBSSxDQUFBO0lBQzVDLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQTtBQUNuRCxDQUFDLENBQUE7QUFFRCxNQUFNLFlBQVksR0FBSSxhQUFxQixFQUFFLENBQUE7QUFFN0MsSUFBVSxNQUFNLENBc2ZmO0FBdGZELFdBQVUsTUFBTTtJQUNkLFlBQVksQ0FBQTtJQUVaLE1BQU0sY0FBYyxHQUFHLENBQUMsQ0FBQTtJQUN4QixNQUFNLFlBQVksR0FBRyxDQUFDLENBQUE7SUFFdEIsSUFBSSxjQUFjLEdBQUcsQ0FBQyxDQUFBO0lBRXRCLE1BQU0sY0FBYyxHQUFVLEVBQUUsQ0FBQTtJQUNoQyxNQUFNLE1BQU0sR0FBZSxFQUFFLENBQUE7SUFFN0IsTUFBTSxRQUFRLEdBQUc7UUFDZixPQUFPLEVBQUUsRUFBRTtLQUNaLENBQUE7SUFFRCxNQUFNLGlCQUFpQixHQUEyQixFQUFFLENBQUE7SUFFcEQsU0FBZ0IsTUFBTSxDQUFDLE1BQTJCO1FBQ2hELElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxFQUFFO1lBQzlCLEtBQUssTUFBTSxDQUFDLElBQUksTUFBTSxFQUFFO2dCQUN0QixJQUFJLE1BQU0sQ0FBQyxjQUFj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QVE7Z0JBQ1gsT0FBTyxVQUFVLENBQUE7U0FDcEI7UUFDRCxJQUFJLFlBQVksRUFBRTtZQUNoQixPQUFPLGFBQWEsQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDLENBQUE7U0FDL0M7UUFDRCxPQUFPLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBQ3RDLENBQUM7SUFFRCxPQUFPLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQTtBQUN2QixDQUFDLEVBdGZTLE1BQU0sS0FBTixNQUFNLFFBc2ZmO0FBRUQsWUFBWSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFBO0FBQ25DLFlBQVksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFBIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzICovXG50eXBlIE1vZHVsZSA9IHtcbiAgbmFtZTogc3RyaW5nXG4gIGRjbGFtZDogMSB8IDJcbiAgcGFyZW50OiBzdHJpbmcgfCBudWxsXG4gIGRlcGVuZGFudHM6IFNldDxzdHJpbmc+XG4gIGRlcGVuZGVuY2llczogQXJyYXk8c3RyaW5nPlxuICBoYW5kbGVyczogTW9kdWxlTG9hZGVkSGFuZGxlcltdXG4gIGV4cG9ydHM6IGFueVxufVxuXG50eXBlIE1vZHVsZUxvYWRlZEhhbmRsZXIgPSAobW9kdWxlOiBNb2R1bGUpID0+IHZvaWRcblxuZGVjbGFyZSBsZXQgb25lcnJvcjogKChlcnI6IEVycm9yKSA9PiB2b2lkKSB8IHVuZGVmaW5lZFxuXG4vLyBBIG5haXZlIGF0dGVtcHQgYXQgZ2V0dGluZyB0aGUgZ2xvYmFsIGB0aGlzYC4gRG9u4oCZdCB1c2UgYHRoaXNgIVxuY29uc3QgZ2V0R2xvYmFsVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gZ2xvYmFsVGhpc1xuICAvLyBAdHMtaWdub3JlXG4gIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHJldHVybiBzZWxmXG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSByZXR1cm4gd2luZG93XG4gIC8vIE5vdGU6IHRoaXMgbWlnaHQgc3RpbGwgcmV0dXJuIHRoZSB3cm9uZyByZXN1bHQhXG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKHR5cGVvZiB0aGlzICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIHRoaXNcbiAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gbG9jYXRlIGdsb2JhbCBgdGhpc2AnKVxufVxuXG5jb25zdCBnbG9iYWxPYmplY3QgPSAoZ2V0R2xvYmFsVGhpcyBhcyBhbnkpKClcblxubmFtZXNwYWNlIGxvYWRlciB7XG4gICd1c2Ugc3RyaWN0J1xuXG4gIGNvbnN0IE1PRFVMRV9MT0FESU5HID0gMVxuICBjb25zdCBNT0RVTEVfUkVBRFkgPSAyXG5cbiAgbGV0IHVubmFtZWRNb2R1bGVzID0gMFxuXG4gIGNvbnN0IGFub255bW91c1F1ZXVlOiBhbnlbXSA9IFtdXG4gIGNvbnN0IGN5Y2xlczogc3RyaW5nW11bXSA9IFtdXG5cbiAgY29uc3Qgc2V0dGluZ3MgPSB7XG4gICAgYmFzZVVybDogJydcbiAgfVxuXG4gIGNvbnN0IHJlZ2lzdGVyZWRNb2R1bGVzOiBSZWNvcmQ8c3RyaW5nLCBNb2R1bGU+ID0ge31cblxuICBleHBvcnQgZnVuY3Rpb24gY29uZmlnKGNvbmZpZzogUmVjb3JkPHN0cmluZywgYW55Pikge1xuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgZm9yIChjb25zdCB4IGluIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnLmhhc093blByb3BlcnR5KHgpKSB7XG4gICAgICAgICAgOyhzZXR0aW5ncyBhcyBhbnkpW3hdID0gY29uZmlnW3hdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gZGVmaW5lKGZhY3Rvcnk6IEZ1bmN0aW9uKTogdm9pZFxuICBleHBvcnQgZnVuY3Rpb24gZGVmaW5lKGlkOiBzdHJpbmcsIGZhY3Rvcnk6IEZ1bmN0aW9uKTogdm9pZFxuICBleHBvcnQgZnVuY3Rpb24gZGVmaW5lKGRlcGVuZGVuY2llczogc3RyaW5nW10sIGZhY3Rvcnk6IEZ1bmN0aW9uKTogdm9pZFxuICBleHBvcnQgZnVuY3Rpb24gZGVmaW5lKFxuICAgIGlkOiBzdHJpbmcsXG4gICAgZGVwZW5kZW5jaWVzOiBzdHJpbmdbXSxcbiAgICBmYWN0b3J5OiBGdW5jdGlvblxuICApOiB2b2lkXG4gIGV4cG9ydCBmdW5jdGlvbiBkZWZpbmUoXG4gICAgZmlyc3Q6IHN0cmluZyB8IEZ1bmN0aW9uIHwgc3RyaW5nW10sXG4gICAgc2Vjb25kPzogc3RyaW5nW10gfCBzdHJpbmcgfCBGdW5jdGlvbixcbiAgICB0aGlyZD86IEZ1bmN0aW9uIHwgb2JqZWN0XG4gICk6IHZvaWQge1xuICAgIGxldCBtb2R1bGVUb0xvYWQ6IHN0cmluZyB8IG51bGwgPSBudWxsXG4gICAgbGV0IGZhY3Rvcnk6IEZ1bmN0aW9uIHwgb2JqZWN0ID0ge31cbiAgICBsZXQgZGVwZW5kZW5jaWVzOiBzdHJpbmdbXSB8IG51bGwgPSBudWxsXG5cbiAgICBpZiAodHlwZW9mIGZpcnN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBmYWN0b3J5ID0gZmlyc3RcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1vZHVsZVRvTG9hZCA9IGZpcnN0XG5cbiAgICAgIGlmICh0eXBlb2Ygc2Vjb25kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZhY3RvcnkgPSBzZWNvbmRcbiAgICAgIH0gZWxzZSBpZiAoc2Vjb25kIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZGVwZW5kZW5jaWVzID0gc2Vjb25kXG4gICAgICAgIGZhY3RvcnkgPSB0aGlyZCFcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpcnN0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGRlcGVuZGVuY2llcyA9IGZpcnN0XG4gICAgICBpZiAodHlwZW9mIHNlY29uZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmYWN0b3J5ID0gc2Vjb25kXG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzIHx8IFsncmVxdWlyZScsICdleHBvcnRzJywgJ21vZHVsZSddXG5cbiAgICBpZiAobW9kdWxlVG9Mb2FkID09PSBudWxsKSB7XG4gICAgICBtb2R1bGVUb0xvYWQgPSBgdW5uYW1lZC1tb2R1bGUtJHt1bm5hbWVkTW9kdWxlcysrfWBcbiAgICB9XG5cbiAgICBtb2R1bGVUb0xvYWQgPSBub3JtYWxpemVNb2R1bGVJZChtb2R1bGVUb0xvYWQpXG5cbiAgICBmdW5jdGlvbiByZWFkeShkZXBzOiBhbnlbXSkge1xuICAgICAgY29uc3QgbW9kdWxlID0gcmVnaXN0ZXJlZE1vZHVsZXNbbW9kdWxlVG9Mb2FkIV1cblxuICAgICAgaWYgKCFtb2R1bGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGFjY2VzcyByZWdpc3RlcmVkIG1vZHVsZSAnICsgbW9kdWxlVG9Mb2FkKVxuXG4gICAgICBsZXQgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzXG5cbiAgICAgIGV4cG9ydHMgPVxuICAgICAgICB0eXBlb2YgZmFjdG9yeSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgID8gZmFjdG9yeS5hcHBseShnbG9iYWxPYmplY3QsIGRlcHMpIHx8IGV4cG9ydHNcbiAgICAgICAgICA6IGZhY3RvcnlcblxuICAgICAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzXG5cbiAgICAgIG1vZHVsZVJlYWR5KG1vZHVsZVRvTG9hZCEpXG4gICAgfVxuXG4gICAgZGVwZW5kZW5jaWVzID0gKGRlcGVuZGVuY2llcyB8fCBbXSkubWFwKChkZXApID0+XG4gICAgICByZXNvbHZlKG1vZHVsZVRvTG9hZCEsIGRlcClcbiAgICApXG5cbiAgICBpZiAoIXJlZ2lzdGVyZWRNb2R1bGVzW21vZHVsZVRvTG9hZF0pIHtcbiAgICAgIHJlZ2lzdGVyZWRNb2R1bGVzW21vZHVsZVRvTG9hZF0gPSB7XG4gICAgICAgIG5hbWU6IG1vZHVsZVRvTG9hZCEsXG4gICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgZGNsYW1kOiBNT0RVTEVfTE9BRElORyxcbiAgICAgICAgZGVwZW5kZW5jaWVzLFxuICAgICAgICBoYW5kbGVyczogW10sXG4gICAgICAgIGV4cG9ydHM6IHt9LFxuICAgICAgICBkZXBlbmRhbnRzOiBuZXcgU2V0KClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3RlcmVkTW9kdWxlc1ttb2R1bGVUb0xvYWRdLmRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llc1xuXG4gICAgcmVxdWlyZShkZXBlbmRlbmNpZXMsIHJlYWR5LCAoZXJyOiBFcnJvcikgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBvbmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG9uZXJyb3IoZXJyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgfSwgbW9kdWxlVG9Mb2FkISlcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgZGVmaW5lIHtcbiAgICBleHBvcnQgY29uc3QgYW1kID0ge31cbiAgICBleHBvcnQgY29uc3QgbW9kdWxlcyA9IHJlZ2lzdGVyZWRNb2R1bGVzXG4gIH1cblxuICBmdW5jdGlvbiBtb2R1bGVSZWFkeShtb2R1bGVOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBtb2R1bGUgPSByZWdpc3RlcmVkTW9kdWxlc1ttb2R1bGVOYW1lXVxuXG4gICAgaWYgKCFtb2R1bGUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBhY2Nlc3MgcmVnaXN0ZXJlZCBtb2R1bGUgJyArIG1vZHVsZU5hbWUpXG5cbiAgICBtb2R1bGUuZGNsYW1kID0gTU9EVUxFX1JFQURZXG5cbiAgICBjb25zdCBoYW5kbGVyczogTW9kdWxlTG9hZGVkSGFuZGxlcltdID0gbW9kdWxlLmhhbmRsZXJzXG5cbiAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGhhbmRsZXJzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgIGhhbmRsZXJzW3hdKHJlZ2lzdGVyZWRNb2R1bGVzW21vZHVsZU5hbWVdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXYWxrcyAocmVjdXJzaXZlbHkpIHRoZSBkZXBlbmRlbmNpZXMgb2YgJ2Zyb20nIGluIHNlYXJjaCBvZiAndG8nLlxuICAgKiBSZXR1cm5zIGN5Y2xlIGFzIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0Q3ljbGVQYXRoKFxuICAgIGZyb21Nb2R1bGU6IHN0cmluZyxcbiAgICB0b01vZHVsZTogc3RyaW5nLFxuICAgIGRlcHRoOiBudW1iZXJcbiAgKTogc3RyaW5nW10gfCBudWxsIHtcbiAgICBpZiAoIXJlZ2lzdGVyZWRNb2R1bGVzW2Zyb21Nb2R1bGVdKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGlmIChmcm9tTW9kdWxlID09PSB0b01vZHVsZSB8fCBkZXB0aCA9PT0gNTApIHJldHVybiBbZnJvbU1vZHVsZV1cblxuICAgIGNvbnN0IGRlcGVuZGVuY2llcyA9IHJlZ2lzdGVyZWRNb2R1bGVzW2Zyb21Nb2R1bGVdLmRlcGVuZGVuY2llc1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgcGF0aCA9IGdldEN5Y2xlUGF0aChkZXBlbmRlbmNpZXNbaV0sIHRvTW9kdWxlLCBkZXB0aCArIDEpXG4gICAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgICBwYXRoLnB1c2goZnJvbU1vZHVsZSlcbiAgICAgICAgcmV0dXJuIHBhdGhcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIFdhbGtzIChyZWN1cnNpdmVseSkgdGhlIGRlcGVuZGVuY2llcyBvZiAnZnJvbScgaW4gc2VhcmNoIG9mICd0bycuXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBzdWNoIGEgcGF0aCBvciBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwYXJhbSBmcm9tIE1vZHVsZSBpZCB0byBzdGFydCBhdFxuICAgKiBAcGFyYW0gdG8gTW9kdWxlIGlkIHRvIGxvb2sgZm9yXG4gICAqL1xuICBmdW5jdGlvbiBoYXNEZXBlbmRlbmN5UGF0aChmcm9tSWQ6IHN0cmluZywgdG9JZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZnJvbSA9IHJlZ2lzdGVyZWRNb2R1bGVzW2Zyb21JZF1cbiAgICBpZiAoIWZyb20pIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGluUXVldWU6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge31cbiAgICBmb3IgKGNvbnN0IGkgaW4gcmVnaXN0ZXJlZE1vZHVsZXMpIHtcbiAgICAgIGluUXVldWVbaV0gPSBmYWxzZVxuICAgIH1cbiAgICBjb25zdCBxdWV1ZTogTW9kdWxlW10gPSBbXVxuXG4gICAgLy8gSW5zZXJ0ICdmcm9tJyBpbiBxdWV1ZVxuICAgIHF1ZXVlLnB1c2goZnJvbSlcbiAgICBpblF1ZXVlW2Zyb21JZF0gPSB0cnVlXG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgLy8gUG9wIGZpcnN0IGluc2VydGVkIGVsZW1lbnQgb2YgcXVldWVcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBxdWV1ZS5zaGlmdCgpIVxuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gZWxlbWVudC5kZXBlbmRlbmNpZXNcbiAgICAgIGlmIChkZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgLy8gV2FsayB0aGUgZWxlbWVudCdzIGRlcGVuZGVuY2llc1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXVxuXG4gICAgICAgICAgaWYgKGRlcGVuZGVuY3kgPT09IHRvSWQpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIGEgcGF0aCB0byAndG8nXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGRlcGVuZGVuY3lNb2R1bGUgPSByZWdpc3RlcmVkTW9kdWxlc1tkZXBlbmRlbmN5XVxuICAgICAgICAgIGlmIChkZXBlbmRlbmN5TW9kdWxlICYmICFpblF1ZXVlW2RlcGVuZGVuY3ldKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgJ2RlcGVuZGVuY3knIGluIHF1ZXVlXG4gICAgICAgICAgICBpblF1ZXVlW2RlcGVuZGVuY3ldID0gdHJ1ZVxuICAgICAgICAgICAgcXVldWUucHVzaChkZXBlbmRlbmN5TW9kdWxlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXJlIGlzIG5vIHBhdGggdG8gJ3RvJ1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmUoXG4gICAgZGVwZW5kZW5jaWVzOiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgICBjYWxsYmFjazogKGRlcHM6IGFueVtdKSA9PiB2b2lkLFxuICAgIGVycm9yQ2FsbGJhY2s6IEZ1bmN0aW9uLFxuICAgIHBhcmVudE1vZHVsZTogc3RyaW5nXG4gICkge1xuICAgIGNvbnN0IGRlcGVuZGVuY2llc1Jlc3VsdHM6IGFueVtdID0gbmV3IEFycmF5KGRlcGVuZGVuY2llcy5sZW5ndGgpLmZpbGwobnVsbClcbiAgICBsZXQgbG9hZGVkQ291bnQgPSAwXG4gICAgbGV0IGhhc0xvYWRlZCA9IGZhbHNlXG5cbiAgICBpZiAodHlwZW9mIGRlcGVuZGVuY2llcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChyZWdpc3RlcmVkTW9kdWxlc1tkZXBlbmRlbmNpZXNdKSB7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkTW9kdWxlc1tkZXBlbmRlbmNpZXNdLmRjbGFtZCA9PT0gTU9EVUxFX0xPQURJTkcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVHJ5aW5nIHRvIGxvYWQgJHtkZXBlbmRlbmNpZXN9IGZyb20gJHtwYXJlbnRNb2R1bGV9LiBUaGUgZmlyc3QgbW9kdWxlIGlzIHN0aWxsIGxvYWRpbmcuYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZE1vZHVsZXNbZGVwZW5kZW5jaWVzXVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBkZXBlbmRlbmNpZXMgK1xuICAgICAgICAgICcgaGFzIG5vdCBiZWVuIGRlZmluZWQuIFBsZWFzZSBpbmNsdWRlIGl0IGFzIGEgZGVwZW5kZW5jeSBpbiAnICtcbiAgICAgICAgICBwYXJlbnRNb2R1bGUgK1xuICAgICAgICAgIFwiJ3MgZGVmaW5lKClcIlxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGRlcHNMZW5ndGggPSBkZXBlbmRlbmNpZXMubGVuZ3RoXG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZGVwc0xlbmd0aDsgaW5kZXgrKykge1xuICAgICAgc3dpdGNoIChkZXBlbmRlbmNpZXNbaW5kZXhdKSB7XG4gICAgICAgIGNhc2UgJ3JlcXVpcmUnOlxuICAgICAgICAgIGNvbnN0IF9yZXF1aXJlOiB0eXBlb2YgcmVxdWlyZSA9IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIG5ld19tb2R1bGU6IHN0cmluZyB8IHN0cmluZ1tdLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHZvaWQsXG4gICAgICAgICAgICBlcnJvckNhbGxiYWNrOiBGdW5jdGlvblxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVpcmUobmV3X21vZHVsZSwgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2ssIHBhcmVudE1vZHVsZSlcbiAgICAgICAgICB9IGFzIGFueVxuICAgICAgICAgIF9yZXF1aXJlLnRvVXJsID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRvVXJsKG1vZHVsZSwgcGFyZW50TW9kdWxlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBkZXBlbmRlbmNpZXNSZXN1bHRzW2luZGV4XSA9IF9yZXF1aXJlXG4gICAgICAgICAgbG9hZGVkQ291bnQrK1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJ2V4cG9ydHMnOlxuICAgICAgICAgIGlmICghcmVnaXN0ZXJlZE1vZHVsZXNbcGFyZW50TW9kdWxlXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnUGFyZW50IG1vZHVsZSAnICsgcGFyZW50TW9kdWxlICsgJyBub3QgcmVnaXN0ZXJlZCB5ZXQnXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVwZW5kZW5jaWVzUmVzdWx0c1tpbmRleF0gPSByZWdpc3RlcmVkTW9kdWxlc1twYXJlbnRNb2R1bGVdLmV4cG9ydHNcbiAgICAgICAgICBsb2FkZWRDb3VudCsrXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnbW9kdWxlJzpcbiAgICAgICAgICBkZXBlbmRlbmNpZXNSZXN1bHRzW2luZGV4XSA9IHtcbiAgICAgICAgICAgIGlkOiBwYXJlbnRNb2R1bGUsXG4gICAgICAgICAgICB1cmk6IHRvVXJsKHBhcmVudE1vZHVsZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgbG9hZGVkQ291bnQrK1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgdGhlbiB3ZSByZXNvbHZlIHRoZSBtb2R1bGUgZXZlbiBpZiBpdCBoYXNuJ3QgbG9hZGVkIHlldFxuICAgICAgICAgIGNvbnN0IGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaW5kZXhdXG5cbiAgICAgICAgICBjb25zdCBoYXNDeWNsZXMgPSBoYXNEZXBlbmRlbmN5UGF0aChkZXBlbmRlbmN5LCBwYXJlbnRNb2R1bGUpXG5cbiAgICAgICAgICBjb25zdCBoYW5kbGVMb2FkZWRNb2R1bGUgPSAoKSA9PiB7XG4gICAgICAgICAgICBkZXBlbmRlbmNpZXNSZXN1bHRzW2luZGV4XSA9IHJlZ2lzdGVyZWRNb2R1bGVzW2RlcGVuZGVuY3ldLmV4cG9ydHNcbiAgICAgICAgICAgIGxvYWRlZENvdW50KytcbiAgICAgICAgICAgIGlmIChsb2FkZWRDb3VudCA9PT0gZGVwc0xlbmd0aCAmJiBjYWxsYmFjaykge1xuICAgICAgICAgICAgICBoYXNMb2FkZWQgPSB0cnVlXG4gICAgICAgICAgICAgIGNhbGxiYWNrKGRlcGVuZGVuY2llc1Jlc3VsdHMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGhhc0N5Y2xlcykge1xuICAgICAgICAgICAgY29uc3QgY3ljbGVQYXRoID0gZ2V0Q3ljbGVQYXRoKGRlcGVuZGVuY3ksIHBhcmVudE1vZHVsZSwgMClcbiAgICAgICAgICAgIGlmIChjeWNsZVBhdGgpIHtcbiAgICAgICAgICAgICAgY3ljbGVQYXRoLnJldmVyc2UoKVxuICAgICAgICAgICAgICBjeWNsZVBhdGgucHVzaChkZXBlbmRlbmN5KVxuICAgICAgICAgICAgICBjeWNsZXMucHVzaChjeWNsZVBhdGgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2FkKGRlcGVuZGVuY3ksICgpID0+IHt9LCBlcnJvckNhbGxiYWNrLCBwYXJlbnRNb2R1bGUpXG4gICAgICAgICAgICBoYW5kbGVMb2FkZWRNb2R1bGUoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2FkKGRlcGVuZGVuY3ksIGhhbmRsZUxvYWRlZE1vZHVsZSwgZXJyb3JDYWxsYmFjaywgcGFyZW50TW9kdWxlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhc0xvYWRlZCAmJiBsb2FkZWRDb3VudCA9PT0gZGVwc0xlbmd0aCAmJiBjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soZGVwZW5kZW5jaWVzUmVzdWx0cylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVNZXRob2RIYW5kbGVyKHJwY0hhbmRsZTogc3RyaW5nLCBtZXRob2Q6IE1ldGhvZERlc2NyaXB0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRjbC5jYWxsUnBjKFxuICAgICAgICBycGNIYW5kbGUsXG4gICAgICAgIG1ldGhvZC5uYW1lLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgIGFub255bW91c1F1ZXVlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKVxuICAgICAgKVxuICAgIH1cbiAgfVxuXG4gIC8vIHJldHVybnM6IHJlc29sdmVkTW9kdWxlTmFtZVxuICBmdW5jdGlvbiByZXNvbHZlKGZyb21Nb2R1bGU6IHN0cmluZywgdG9Nb2R1bGU6IHN0cmluZykge1xuICAgIHJldHVybiBmcm9tTW9kdWxlID8gdG9VcmwodG9Nb2R1bGUsIGZyb21Nb2R1bGUpIDogdG9Nb2R1bGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvYWQoXG4gICAgbW9kdWxlTmFtZTogc3RyaW5nLFxuICAgIGNhbGxiYWNrOiBNb2R1bGVMb2FkZWRIYW5kbGVyLFxuICAgIGVycm9yQ2FsbGJhY2s6IEZ1bmN0aW9uLFxuICAgIHBhcmVudE1vZHVsZTogc3RyaW5nXG4gICkge1xuICAgIGlmIChyZWdpc3RlcmVkTW9kdWxlc1ttb2R1bGVOYW1lXSkge1xuICAgICAgcmVnaXN0ZXJlZE1vZHVsZXNbbW9kdWxlTmFtZV0uZGVwZW5kYW50cy5hZGQocGFyZW50TW9kdWxlKVxuXG4gICAgICBpZiAocmVnaXN0ZXJlZE1vZHVsZXNbbW9kdWxlTmFtZV0uZGNsYW1kID09PSBNT0RVTEVfTE9BRElORykge1xuICAgICAgICBjYWxsYmFjayAmJiByZWdpc3RlcmVkTW9kdWxlc1ttb2R1bGVOYW1lXS5oYW5kbGVycy5wdXNoKGNhbGxiYWNrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2socmVnaXN0ZXJlZE1vZHVsZXNbbW9kdWxlTmFtZV0pXG4gICAgICB9XG5cbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICByZWdpc3RlcmVkTW9kdWxlc1ttb2R1bGVOYW1lXSA9IHtcbiAgICAgICAgbmFtZTogbW9kdWxlTmFtZSxcbiAgICAgICAgcGFyZW50OiBwYXJlbnRNb2R1bGUsXG4gICAgICAgIGRjbGFtZDogTU9EVUxFX0xPQURJTkcsXG4gICAgICAgIGhhbmRsZXJzOiBbY2FsbGJhY2tdLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IFtdLFxuICAgICAgICBkZXBlbmRhbnRzOiBuZXcgU2V0KFtwYXJlbnRNb2R1bGVdKSxcbiAgICAgICAgZXhwb3J0czoge31cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kdWxlTmFtZS5pbmRleE9mKCdAJykgPT09IDAgfHwgbW9kdWxlTmFtZS5pbmRleE9mKCd+JykgPT09IDApIHtcbiAgICAgIGNvbnN0IGV4cG9ydHMgPSByZWdpc3RlcmVkTW9kdWxlc1ttb2R1bGVOYW1lXS5leHBvcnRzXG4gICAgICBpZiAodHlwZW9mIGRjbC5sb2FkTW9kdWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGRjbFxuICAgICAgICAgIC5sb2FkTW9kdWxlKG1vZHVsZU5hbWUsIGV4cG9ydHMpXG4gICAgICAgICAgLnRoZW4oKGRlc2NyaXB0b3I6IE1vZHVsZURlc2NyaXB0b3IpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiBkZXNjcmlwdG9yLm1ldGhvZHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gZGVzY3JpcHRvci5tZXRob2RzW2ldXG4gICAgICAgICAgICAgIGV4cG9ydHNbbWV0aG9kLm5hbWVdID0gY3JlYXRlTWV0aG9kSGFuZGxlcihcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLnJwY0hhbmRsZSxcbiAgICAgICAgICAgICAgICBtZXRob2RcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb2R1bGVSZWFkeShtb2R1bGVOYW1lKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNhdGNoKChlOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGVycm9yQ2FsbGJhY2soZSlcbiAgICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdBc3luY2hyb25vdXMgbW9kdWxlcyB3aWxsIG5vdCB3b3JrIGJlY2F1c2UgbG9hZE1vZHVsZSBmdW5jdGlvbiBpcyBub3QgcHJlc2VudCdcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgZGNsICE9PSAndW5kZWZpbmVkJykge1xuICAgIGRjbC5vblN0YXJ0KCgpID0+IHtcbiAgICAgIGNvbnN0IHVua25vd25Nb2R1bGVzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgICAgIGNvbnN0IG5vdExvYWRlZE1vZHVsZXM6IE1vZHVsZVtdID0gW11cblxuICAgICAgZm9yIChjb25zdCBpIGluIHJlZ2lzdGVyZWRNb2R1bGVzKSB7XG4gICAgICAgIGlmIChyZWdpc3RlcmVkTW9kdWxlc1tpXSkge1xuICAgICAgICAgIGlmIChyZWdpc3RlcmVkTW9kdWxlc1tpXS5kY2xhbWQgPT09IE1PRFVMRV9MT0FESU5HKSB7XG4gICAgICAgICAgICBub3RMb2FkZWRNb2R1bGVzLnB1c2gocmVnaXN0ZXJlZE1vZHVsZXNbaV0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVnaXN0ZXJlZE1vZHVsZXNbaV0uZGVwZW5kZW5jaWVzLmZvckVhY2goKCQpID0+IHtcbiAgICAgICAgICAgIGlmICgkID09PSAncmVxdWlyZScgfHwgJCA9PT0gJ2V4cG9ydHMnIHx8ICQgPT09ICdtb2R1bGUnKSByZXR1cm5cbiAgICAgICAgICAgIGlmICghcmVnaXN0ZXJlZE1vZHVsZXNbJF0pIHVua25vd25Nb2R1bGVzLmFkZCgkKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgZXJyb3JQYXJ0czogc3RyaW5nW10gPSBbXVxuXG4gICAgICBpZiAoY3ljbGVzLmxlbmd0aCkge1xuICAgICAgICBlcnJvclBhcnRzLnB1c2goXG4gICAgICAgICAgYFxcbj4gQ3ljbGljIGRlcGVuZGVuY2llczogJHtjeWNsZXNcbiAgICAgICAgICAgIC5tYXAoKCQpID0+ICdcXG4gIC0gJyArICQuam9pbignIC0+ICcpKVxuICAgICAgICAgICAgLmpvaW4oJycpfWBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAodW5rbm93bk1vZHVsZXMuc2l6ZSkge1xuICAgICAgICBlcnJvclBhcnRzLnB1c2goXG4gICAgICAgICAgYFxcbj4gVW5kZWNsYXJlZC91bmtub3duIG1vZHVsZXM6ICR7QXJyYXkuZnJvbSh1bmtub3duTW9kdWxlcylcbiAgICAgICAgICAgIC5tYXAoKCQpID0+ICdcXG4gIC0gJyArICQpXG4gICAgICAgICAgICAuam9pbignJyl9YFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChub3RMb2FkZWRNb2R1bGVzLmxlbmd0aCkge1xuICAgICAgICBlcnJvclBhcnRzLnB1c2goXG4gICAgICAgICAgYFxcbj4gVGhlc2UgbW9kdWxlcyBkaWRuJ3QgbG9hZDogJHtub3RMb2FkZWRNb2R1bGVzXG4gICAgICAgICAgICAubWFwKCgkKSA9PiAnXFxuICAtICcgKyAkLm5hbWUpXG4gICAgICAgICAgICAuam9pbignJyl9LlxcbmBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoZXJyb3JQYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yUGFydHMuam9pbignXFxuJykpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgJ2EvLi4vbmFtZScgdG8gJ25hbWUnLCBldGMuXG4gICAqL1xuICBmdW5jdGlvbiBub3JtYWxpemVNb2R1bGVJZChtb2R1bGVJZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBsZXQgciA9IG1vZHVsZUlkLFxuICAgICAgcGF0dGVybjogUmVnRXhwXG5cbiAgICAvLyByZXBsYWNlIC8uLyA9PiAvXG4gICAgcGF0dGVybiA9IC9cXC9cXC5cXC8vXG4gICAgd2hpbGUgKHBhdHRlcm4udGVzdChyKSkge1xuICAgICAgciA9IHIucmVwbGFjZShwYXR0ZXJuLCAnLycpXG4gICAgfVxuXG4gICAgLy8gcmVwbGFjZSBeLi8gPT4gbm90aGluZ1xuICAgIHIgPSByLnJlcGxhY2UoL15cXC5cXC8vZywgJycpXG5cbiAgICAvLyByZXBsYWNlIC9hYS8uLi8gPT4gLyAoQlVUIElHTk9SRSAvLi4vLi4vKVxuICAgIHBhdHRlcm4gPVxuICAgICAgL1xcLygoW15cXC9dKXwoW15cXC9dW15cXC9cXC5dKXwoW15cXC9cXC5dW15cXC9dKXwoW15cXC9dW15cXC9dW15cXC9dKykpXFwvXFwuXFwuXFwvL1xuICAgIHdoaWxlIChwYXR0ZXJuLnRlc3QocikpIHtcbiAgICAgIHIgPSByLnJlcGxhY2UocGF0dGVybiwgJy8nKVxuICAgIH1cblxuICAgIC8vIHJlcGxhY2UgXmFhLy4uLyA9PiBub3RoaW5nIChCVVQgSUdOT1JFIC4uLy4uLylcbiAgICByID0gci5yZXBsYWNlKFxuICAgICAgL14oKFteXFwvXSl8KFteXFwvXVteXFwvXFwuXSl8KFteXFwvXFwuXVteXFwvXSl8KFteXFwvXVteXFwvXVteXFwvXSspKVxcL1xcLlxcLlxcLy8sXG4gICAgICAnJ1xuICAgIClcblxuICAgIC8vIHJlcGxhY2UgXi8gPT4gbm90aGluZ1xuICAgIHIgPSByLnJlcGxhY2UoL15cXC8vZywgJycpXG5cbiAgICByZXR1cm4gclxuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmUgcmVsYXRpdmUgbW9kdWxlIGlkc1xuICAgKi9cbiAgZnVuY3Rpb24gcmVzb2x2ZU1vZHVsZShtb2R1bGVJZDogc3RyaW5nLCBwYXJlbnRNb2R1bGU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IHJlc3VsdCA9IG1vZHVsZUlkXG5cbiAgICBpZiAoIXJlc3VsdC5zdGFydHNXaXRoKCdAJykgJiYgIXJlc3VsdC5zdGFydHNXaXRoKCd+JykpIHtcbiAgICAgIGlmIChyZXN1bHQuc3RhcnRzV2l0aCgnLi8nKSB8fCByZXN1bHQuc3RhcnRzV2l0aCgnLi4vJykpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFBhdGggPSBwYXJlbnRNb2R1bGUuc3BsaXQoJy8nKVxuICAgICAgICBjdXJyZW50UGF0aC5wb3AoKVxuICAgICAgICByZXN1bHQgPSBub3JtYWxpemVNb2R1bGVJZChjdXJyZW50UGF0aC5qb2luKCcvJykgKyAnLycgKyByZXN1bHQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gdG9VcmwobW9kdWxlTmFtZTogc3RyaW5nLCBwYXJlbnRNb2R1bGU/OiBzdHJpbmcpIHtcbiAgICBzd2l0Y2ggKG1vZHVsZU5hbWUpIHtcbiAgICAgIGNhc2UgJ3JlcXVpcmUnOlxuICAgICAgY2FzZSAnZXhwb3J0cyc6XG4gICAgICBjYXNlICdtb2R1bGUnOlxuICAgICAgICByZXR1cm4gbW9kdWxlTmFtZVxuICAgIH1cbiAgICBpZiAocGFyZW50TW9kdWxlKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZU1vZHVsZShtb2R1bGVOYW1lLCBwYXJlbnRNb2R1bGUpXG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVNb2R1bGVJZChtb2R1bGVOYW1lKVxuICB9XG5cbiAgcmVxdWlyZS50b1VybCA9IHRvVXJsXG59XG5cbmdsb2JhbE9iamVjdC5kZWZpbmUgPSBsb2FkZXIuZGVmaW5lXG5nbG9iYWxPYmplY3QuZGNsYW1kID0gbG9hZGVyXG4iXX0=